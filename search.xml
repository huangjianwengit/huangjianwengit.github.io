<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Method Swizzling[swift]]]></title>
    <url>%2F2018%2F11%2F20%2FSwizzling%5BSwift%5D%2F</url>
    <content type="text"><![CDATA[引言​ 在日常开发中，程序员（媛）要面对各种各样的需求，在某些特殊情况下Apple提供的API无法满足我们的需求，这时runtime就派上了用场。 Swift中被废弃的+load（）和+initialize（）我们知道OC中有两个方法+load（）和+initialize（）。 +load(): app启动的时候会加载所有的类,此时就会调用每个类的load方法.+initialize(): 第一次初始化这个类的时候会被调用. 然而在目前的swift版本中这两个方法都不可用了,那现在我们要在这个阶段搞事情该怎么做? 例如method swizzling这个强大的神器，作为为坚强的人类——程序员怎么可能就这样屈服呢。 JORDAN SMITH大神给出了一种很巧解决方案.UIApplication有一个next属性,它会在applicationDidFinishLaunching之前被调用,这个时候通过runtime获取到所有类的列表,然后向所有遵循SelfAware协议的类发送消息. ##交换方法Methond Swizzling 黑魔法Method Swizzling在swift中实现的两个要点 swizzling 应该保证只会执行一次. swizzling 应该在加载所有类的时候调用. 下面给出了两个示例供参考: 123456789101112131415161718192021222324252627282930313233343536373839404142protocol SelfAware: class &#123; static func awake() static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector)&#125;extension SelfAware &#123; static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) &#123; let originalMethod = class_getInstanceMethod(forClass, originalSelector) let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) guard (originalMethod != nil &amp;&amp; swizzledMethod != nil) else &#123; return &#125; if class_addMethod(forClass, originalSelector, method_getImplementation(swizzledMethod!), method_getTypeEncoding(swizzledMethod!)) &#123; class_replaceMethod(forClass, swizzledSelector, method_getImplementation(originalMethod!), method_getTypeEncoding(originalMethod!)) &#125; else &#123; method_exchangeImplementations(originalMethod!, swizzledMethod!) &#125; &#125;&#125;class NothingToSeeHere &#123; static func harmlessFunction() &#123; let typeCount = Int(objc_getClassList(nil, 0)) let types = UnsafeMutablePointer&lt;AnyClass&gt;.allocate(capacity: typeCount) let autoreleasingTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass&gt;(types) objc_getClassList(autoreleasingTypes, Int32(typeCount)) for index in 0 ..&lt; typeCount &#123; (types[index] as? SelfAware.Type)?.awake() &#125; types.deallocate() &#125;&#125;extension UIApplication &#123; private static let runOnce: Void = &#123; NothingToSeeHere.harmlessFunction() &#125;() override open var next: UIResponder? &#123; UIApplication.runOnce return super.next &#125;&#125; 在SelfAware的extension中为swizzlingForClass做了默认实现,相当于一层封装.引自 实际应用在之前已经完成了Swizzling的实现，但是我们要学会使用啊，磨好了武器不能留着上锈啊（说干就干）。在平时做项目过程中我们需要对不同屏幕尺寸做出适配，包括字体适配。写一个控件就去适配，费时费力，不会偷懒的程序员不是好程序员（这里的偷懒可不是不做事，而是想办法用最简单的方式实现同样的效果）。 新建FontAdapter.swift文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329import Foundationimport UIKitlet screenwidthScale = Screen.Width/320.0let screenheightScale = Screen.Height/568.0// MARK: - 使用运行时实现font大小自适应extension UIButton:SelfAware&#123; static func awake() &#123; UIButton.takeOnceTime swizzleMethod &#125; private static let takeOnceTime: Void = &#123; let originalSelector = #selector(sendAction) let swizzledSelector = #selector(xxx_sendAction(action:to:forEvent:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) &#125;() private static let swizzleMethod:Void = &#123; let originalSelector1 = #selector(UIButton.init(frame:)) let swizzledSelector1 = #selector(swizziedInit(frame:)) ///交换方法 swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) let originalSelector2 = #selector(UIButton.init(coder:)) let swizzledSelector2 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector2, swizzledSelector: swizzledSelector2) &#125;() @objc public func xxx_sendAction(action: Selector, to: AnyObject!, forEvent: UIEvent!) &#123; struct xxx_buttonTapCounter &#123; static var count: Int = 0 &#125; xxx_buttonTapCounter.count += 1 print(xxx_buttonTapCounter.count) xxx_sendAction(action: action, to: to, forEvent: forEvent) &#125; @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125;&#125;extension UILabel:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UILabel.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UILabel.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; &#125;extension UITextField:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UITextField.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UITextField.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; &#125; 到这里已经初步了解了Swizzling 的简单实用，虽然原理并不复杂但是解决了问题，白猫黑猫抓到老鼠就是好猫。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swizzling[swift]</tag>
      </tags>
  </entry>
</search>
