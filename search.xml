<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组越界问题]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言​ 在iOS开发中有时会遇到数组越界的问题，从而导致程序崩溃。所谓的数组越界,就是假如你的下标总数现在为32个,然后你在下一秒又执行了一个方法要从50个数据里惊醒赋值啊 筛选之类的 而你此时数量为32 ，50的数据还没有请求到 往往会出现数组越界的崩溃信息 大概是这样的-[__NSArrayI objectAtIndex:]: index 100 beyond bounds [0 .. 9]&#39; 具体的解决方式我们通常会选择把数组做个判断列如 return nil。为了防止程序崩溃，我们就要对数组越界进行处理。首先你可能会想到创建一个分类写上一个扩展方法，类似于这样： 12345678910-(id)jh_objectAtIndex:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self objectAtIndex:index]; &#125;else&#123; return nil; &#125;&#125; ​ 这样的再取数组内的对象时调用jh_objectAtIndex:方法就解决了数组下标越界导致程序奔溃的问题，但是这样在项目有多个人开发的时候你写的扩展别人可能不知道啊，只有你自己知道调用这个方法可以防止程序奔溃，这不优雅啊。但是这是个小问题，不可能难住我们程序猿啊。 ​ 之前提到过Swizzling （黑魔法）这样的神器，虽然它是一把双刃剑，但是我们应该勇敢的使用这把锋利的剑，谨慎地使用它能极大的提高我们的效率。Swizzling 核心在于method_exchangeImplementations这个方法，这里我们可以创建NSObject (SwizzleMethod)分类封装一下Swizzling 方便之后的使用： import “NSObject+SwizzleMethod.h” 文件 12345678910111213@interface NSObject (SwizzleMethod)/** * 对系统方法进行替换(交换实例方法) * * @param systemSelector 被替换的方法 * @param swizzledSelector 实际使用的方法 * @param error 替换过程中出现的错误消息 * * @return 是否替换成功 */+ (BOOL)SystemSelector:(SEL)systemSelector swizzledSelector:(SEL)swizzledSelector error:(NSError *)error;@end import “NSObject+SwizzleMethod.m”文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;NSObject+SwizzleMethod.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (SwizzleMethod)/** * 对系统方法进行替换 * * @param systemSelector 被替换的方法 * @param swizzledSelector 实际使用的方法 * @param error 替换过程中出现的错误消息 * * @return 是否替换成功 */+ (BOOL)SystemSelector:(SEL)systemSelector swizzledSelector:(SEL)swizzledSelector error:(NSError *)error&#123; Method systemMethod = class_getInstanceMethod(self, systemSelector); if (!systemMethod) &#123; return [[self class] unrecognizedSelector:systemSelector error:error]; &#125; Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector); if (!swizzledMethod) &#123; return [[self class] unrecognizedSelector:swizzledSelector error:error]; &#125; if (class_addMethod([self class], systemSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod([self class], swizzledSelector, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod)); &#125;else&#123; method_exchangeImplementations(systemMethod, swizzledMethod); &#125; return YES;&#125;+ (BOOL)unrecognizedSelector:(SEL)selector error:(NSError *)error&#123; NSString *errorString = [NSString stringWithFormat:@&quot;%@类没有找到%@&quot;, NSStringFromClass([self class]), NSStringFromSelector(selector)]; error = [NSError errorWithDomain:@&quot;NSCocoaErrorDomain&quot; code:-1 userInfo:@&#123;NSLocalizedDescriptionKey:errorString&#125;]; return NO;&#125;@end NSArray #import “NSArray+ErrorHandle.h”文件 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface NSArray (ErrorHandle)/** 为数组分类添加的方法 可以在应用中直接调用 可以防止数组越界导致的crash @param index 传入的取值下标 @return id类型的数据 */- (id)objectAtIndexVerify:(NSUInteger)index;- (id)objectAtIndexedSubscriptVerify:(NSUInteger)idx;@end #import “NSArray+ErrorHandle.h”文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#import &quot;NSArray+ErrorHandle.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;NSObject+SwizzleMethod.h&quot;@implementation NSArray (ErrorHandle)/** * 防止数组越界 */- (id)objectAtIndexVerify:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self objectAtIndex:index]; &#125;else&#123; return nil; &#125;&#125;/** * 防止数组越界 */- (id)objectAtIndexedSubscriptVerify:(NSUInteger)idx&#123; if (idx &lt; self.count) &#123; return [self objectAtIndexedSubscript:idx]; &#125;else&#123; return nil; &#125;&#125;+(void)load&#123; [super load]; //无论怎样 都要保证方法只交换一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //交换NSArray中的objectAtIndex方法 [objc_getClass(&quot;__NSArrayI&quot;) SystemSelector:@selector(objectAtIndex:) swizzledSelector:@selector(sxy_objectAtIndex:) error:nil]; //交换NSArray中的objectAtIndexedSubscript方法 [objc_getClass(&quot;__NSArrayI&quot;) SystemSelector:@selector(objectAtIndexedSubscript:) swizzledSelector:@selector(sxy_objectAtIndexedSubscript:) error:nil]; &#125;);&#125;- (id)sxy_objectAtIndexedSubscript:(NSUInteger)idx&#123; if (idx &lt; self.count) &#123; return [self sxy_objectAtIndexedSubscript:idx]; &#125;else&#123; NSLog(@&quot; 你的 NSArray数组已经越界了 但是已经帮你处理好了 %ld count=%ld&quot;, idx, self.count); return nil; &#125;&#125;- (id)sxy_objectAtIndex:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self sxy_objectAtIndex:index]; &#125;else&#123; NSLog(@&quot; 你的 NSArray数组已经越界了 但是已经帮你处理好了 %ld count=%ld&quot;, index, self.count); return nil; &#125;&#125;@end 这样我们直接使用系统的objectAtIndex:方法例如： 1234567 self.datasource = [NSMutableArray array]; self.datasource = [NSMutableArray arrayWithObject:@[@&quot;1&quot;]];[self.datasource objectAtIndex:4]控制台会输出： 2018-12-04 22:12:47.622751+0800 hh[2884:65056] 你的NSMutableArray数组已经越界 帮你处理好了4 count=1 __NSArrayM2018-12-04 22:12:47.622921+0800 hh[2884:65056] (null) NSMutableArray #import “NSMutableArray+ErrorHandle.h”文件 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;@interface NSMutableArray (ErrorHandle)/** 数组中插入数据 @param object 数据 @param index 下标 */- (void)insertObjectVerify:(id)object atIndex:(NSInteger)index;/** 数组中添加数据 @param object 数据 */- (void)addObjectVerify:(id)object;@end import “NSMutableArray+ErrorHandle.m”文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &quot;NSMutableArray+ErrorHandle.h&quot;#import &quot;NSObject+SwizzleMethod.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (ErrorHandle)/** * 数组中插入数据 */- (void)insertObjectVerify:(id)object atIndex:(NSInteger)index&#123; if (index &lt; self.count &amp;&amp; object) &#123; [self insertObject:object atIndex:index]; &#125;&#125;/** * 数组中添加数据 */- (void)addObjectVerify:(id)object&#123; if (object) &#123; [self addObject:object]; &#125;&#125;+(void)load&#123; [super load]; //无论怎样 都要保证方法只交换一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //交换NSMutableArray中的方法 [objc_getClass(&quot;__NSArrayM&quot;) SystemSelector:@selector(objectAtIndex:) swizzledSelector:@selector(jh_objectAtIndex:) error:nil]; //交换NSMutableArray中的方法 [objc_getClass(&quot;__NSArrayM&quot;) SystemSelector:@selector(objectAtIndexedSubscript:) swizzledSelector:@selector(jh_objectAtIndexedSubscript:) error:nil]; &#125;);&#125;- (id)jh_objectAtIndex:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self jh_objectAtIndex:index]; &#125;else&#123; NSLog(@&quot; 你的NSMutableArray数组已经越界 帮你处理好了%ld count=%ld %@&quot;, index, self.count, [self class]); return nil; &#125;&#125;- (id)jh_objectAtIndexedSubscript:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self jh_objectAtIndexedSubscript:index]; &#125;else&#123; NSLog(@&quot; 你的NSMutableArray数组已经越界 帮你处理好了%ld count=%ld %@&quot;, index, self.count, [self class]); return nil; &#125;&#125;@end ​ 我们还是使用系统的objectAtIndex:方法就可以解决可变数组的越界问题，和你一个项目的小伙伴不知道这个也没问题了。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC与JS交互浅谈]]></title>
    <url>%2F2018%2F11%2F21%2FOC%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[前言​ 苹果端的程序开发审核是困扰开发人员的一大问题，不知多少iOS程序员与苹果爸爸做斗智斗勇，期望自己提交的应用能够一秒上线，当然这是不可能的奢望。虽然近两年苹果已经加速了审核速度，较之以前动则一两个星期的速度，可以说是大大提速了，但是相比较安卓端在审核速度上还是有所差距。为了解决这个问题APP内难免就会有一些web网页，这样在推出新的活动啥的，后台直接更新用户就可以看见啦，不必重新提交新的应用，节省了大量时间，关键是不用看苹果的脸色。 ​ 在工作历程中，有一次遇到这样一个状况：需要在一个web页面中实现分享的功能，web端的妹子是个刚毕业的新手，短时间无法实现这个功能，活动又要赶时间推出，没办法产品经理直接把这个皮球提给我们APP端了（谁让人家是妹子呢，妹子这种动物在程序员界那是大熊猫一样级别的国宝，不得好好照顾嘛）。最后折中采取了在web页面点击按钮，通过JS调用我们APP端的分享来实现这个活动的分享。 我使用了`JSExport`协议：凡是添加了`JSExpor`t协议的类或者协议，所规定的方法，变量等 就会对js开放，我们可以通过js调用到。首先创建OC类： 添加协议1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol JSBridgeObjectProtocol &lt;JSExport&gt;/** 圣诞活动H5调用APP分享 @param url 分享Url @param shareContent 分享内容 */- (void)callOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)shareContent;- (void)callCommonOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)jsonString;@end@interface JSBridgeObject : NSObject&lt;JSBridgeObjectProtocol&gt;@end ​ 实现协议123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;JSBridgeObject.h&quot;//分享#import &quot;YXShareActivityModel.h&quot;#import &quot;UMShareUIManager.h&quot;#import &lt;UMSocialCore/UMSocialCore.h&gt;#import &lt;UShareUI/UShareUI.h&gt;@interface JSBridgeObject ()@property (nonatomic, strong) YXShareActivityModel *shareModel;@end@implementation JSBridgeObject/**活动JS调用的方法(JS调用写法和OC不一样 无参方法 TestJSobject.TestNOParameter(); 有一个参数的方法 TestJSobject.TestOneParameter(TestJSobject.name); 有两个参数的方法 TestJSobject.TestTwoParameterSecondParameter(TestJSobject.name,TestJSobject.age);**/ //实现协议方法- (void)callOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)shareContent&#123; //这里处理web要求帮忙做的事情&#125;- (void)callCommonOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)jsonString&#123; //这里处理web要求帮忙做的事情&#125;- (void)shareToOtherPlatformUrl:(NSString *)url ShareContent:(YXShareActivityModel *)shareModel&#123; //这里处理web要求帮忙做的事情&#125;@end 在合适的时机将我们的对象提供给web12345678910111213//获取到页面的title- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; if (!self.title || self.title.length == 0) &#123; self.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; &#125; JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; self.bridgeObject = [JSBridgeObject new]; context[@&quot;JSBridgeObject&quot;] = self.bridgeObject;&#125; 结语​ 好了到这里已经完美的接过了上面产品经理踢过来的皮球，展现了我大iOS开发人员的魅力，哈哈。。自我臭美中！互帮互助齐力完成任务，最后大家一起happy才是最美的事吗，在帮助别人的时候也是在帮助自己，工作中学习才是最快速的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swizzling[Objective-C]]]></title>
    <url>%2F2018%2F11%2F21%2FSwizzling-Objective-C%2F</url>
    <content type="text"><![CDATA[前言​ 前面的文章我已经介绍了Swift中的Swizzling Method，虽然swift语言有很多优点，但是毕竟是一门刚出来的语言，还处于发展过程中，苹果爹每年一次的大更新可折磨着一大堆苹果开发者。对于一般讲究效率和稳定的公司依旧青睐于Objective-C，毕竟大多数开发者还是比较熟悉的，节约了大多数学习和维护成本。 ​ 额。。。貌似扯得有点多，进入今天的正题吧，在OC中我们不必像swift中那样需要先解决方法的调用问题，API直接提供了两个方法+load（）和+initialize（）。OC本身就是运行时语言，不想swift静态性语言，虽然也能使用runtime，但是只是为了兼容OC，毕竟同一家公司不可能对自己家的东西不认可，那不是打自己脸。（又扯远了，手动尴尬-_-!） +load(): app启动的时候会加载所有的类,此时就会调用每个类的load方法。+initialize(): 第一次初始化这个类的时候会被调用。 ​ 今天依旧解决 字体适配 问题，这里我使用+load(): 方法，在这里替换我想要修改的方法，首先创建一个UIButton+myFont扩展文件，在UIButton+myFont.m文件中写上如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#import &quot;UIButton+myFont.h&quot;@implementation UIButton (myFont) + (void)load&#123; Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:)); Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:)); //用自定义的方法替换系统原始的方法 method_exchangeImplementations(imp, myImp); Method iwf = class_getInstanceMethod([self class], @selector(initWithFrame:)); Method myIwf = class_getInstanceMethod([self class], @selector(myInitWithFrame:)); method_exchangeImplementations(iwf, myIwf);&#125;//这里是为了Xib创建的控件也能有自适应字体大小的效果- (id)myInitWithCoder:(NSCoder*)aDecode&#123; [self myInitWithCoder:aDecode]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.titleLabel.tag != 333)&#123; CGFloat fontSize = self.titleLabel.font.pointSize; self.titleLabel.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;- (id)myInitWithFrame:(CGRect)frame&#123; [self myInitWithFrame:frame] ; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.titleLabel.tag != 333)&#123; CGFloat fontSize = self.titleLabel.font.pointSize; self.titleLabel.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;@end@implementation UILabel (myFont)+ (void)load&#123; Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:)); Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:)); method_exchangeImplementations(imp, myImp); Method iwf = class_getInstanceMethod([self class], @selector(initWithFrame:)); Method myIwf = class_getInstanceMethod([self class], @selector(myInitWithFrame:)); method_exchangeImplementations(iwf, myIwf);&#125;- (id)myInitWithCoder:(NSCoder*)aDecode&#123; [self myInitWithCoder:aDecode]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.tag != 333)&#123; CGFloat fontSize = self.font.pointSize; self.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;- (id)myInitWithFrame:(CGRect)frame&#123; [self myInitWithFrame:frame]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.tag != 333)&#123; CGFloat fontSize = self.font.pointSize; self.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self; &#125; ​ 例子中我就只实现了UIButton和UILable两中控件，你可以同样的原理为UITextFiled、UITextView等控件做出适配，这里我就不一一做示范了，就是这么傲娇☺️。 ​ 其实runtime能做的事情很多字体大小适配只是其应用的很小部分，还有很多妙用等着大家挖掘，像无埋点，限制按钮点击次数等N多的用途，总之一句话：用好runtime，走上人生巅峰。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Swizzling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling[swift]]]></title>
    <url>%2F2018%2F11%2F20%2FSwizzling%5BSwift%5D%2F</url>
    <content type="text"><![CDATA[前言​ 在日常开发中，程序员（媛）要面对各种各样的需求，在某些特殊情况下Apple提供的API无法满足我们的需求，这时runtime就派上了用场。 Swift中被废弃的+load（）和+initialize（）我们知道OC中有两个方法+load（）和+initialize（）。 +load(): app启动的时候会加载所有的类,此时就会调用每个类的load方法.+initialize(): 第一次初始化这个类的时候会被调用. 然而在目前的swift版本中这两个方法都不可用了,那现在我们要在这个阶段搞事情该怎么做? 例如method swizzling这个强大的神器，作为为坚强的人类——程序员怎么可能就这样屈服呢。 JORDAN SMITH大神给出了一种很巧解决方案.UIApplication有一个next属性,它会在applicationDidFinishLaunching之前被调用,这个时候通过runtime获取到所有类的列表,然后向所有遵循SelfAware协议的类发送消息. 交换方法Methond Swizzling黑魔法Method Swizzling在swift中实现的两个要点 swizzling 应该保证只会执行一次. swizzling 应该在加载所有类的时候调用. 下面给出了两个示例供参考: 123456789101112131415161718192021222324252627282930313233343536373839404142protocol SelfAware: class &#123; static func awake() static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector)&#125;extension SelfAware &#123; static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) &#123; let originalMethod = class_getInstanceMethod(forClass, originalSelector) let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) guard (originalMethod != nil &amp;&amp; swizzledMethod != nil) else &#123; return &#125; if class_addMethod(forClass, originalSelector, method_getImplementation(swizzledMethod!), method_getTypeEncoding(swizzledMethod!)) &#123; class_replaceMethod(forClass, swizzledSelector, method_getImplementation(originalMethod!), method_getTypeEncoding(originalMethod!)) &#125; else &#123; method_exchangeImplementations(originalMethod!, swizzledMethod!) &#125; &#125;&#125;class NothingToSeeHere &#123; static func harmlessFunction() &#123; let typeCount = Int(objc_getClassList(nil, 0)) let types = UnsafeMutablePointer&lt;AnyClass&gt;.allocate(capacity: typeCount) let autoreleasingTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass&gt;(types) objc_getClassList(autoreleasingTypes, Int32(typeCount)) for index in 0 ..&lt; typeCount &#123; (types[index] as? SelfAware.Type)?.awake() &#125; types.deallocate() &#125;&#125;extension UIApplication &#123; private static let runOnce: Void = &#123; NothingToSeeHere.harmlessFunction() &#125;() override open var next: UIResponder? &#123; UIApplication.runOnce return super.next &#125;&#125; 在SelfAware的extension中为swizzlingForClass做了默认实现,相当于一层封装。引自Dariel 实际应用在之前已经完成了Swizzling的实现，但是我们要学会使用啊，磨好了武器不能留着上锈啊（说干就干）。在平时做项目过程中我们需要对不同屏幕尺寸做出适配，包括字体适配。写一个控件就去适配，费时费力，不会偷懒的程序员不是好程序员（这里的偷懒可不是不做事，而是想办法用最简单的方式实现同样的效果）。 新建FontAdapter.swift文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329import Foundationimport UIKitlet screenwidthScale = Screen.Width/320.0let screenheightScale = Screen.Height/568.0// MARK: - 使用运行时实现font大小自适应extension UIButton:SelfAware&#123; static func awake() &#123; UIButton.takeOnceTime swizzleMethod &#125; private static let takeOnceTime: Void = &#123; let originalSelector = #selector(sendAction) let swizzledSelector = #selector(xxx_sendAction(action:to:forEvent:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) &#125;() private static let swizzleMethod:Void = &#123; let originalSelector1 = #selector(UIButton.init(frame:)) let swizzledSelector1 = #selector(swizziedInit(frame:)) ///交换方法 swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) let originalSelector2 = #selector(UIButton.init(coder:)) let swizzledSelector2 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector2, swizzledSelector: swizzledSelector2) &#125;() @objc public func xxx_sendAction(action: Selector, to: AnyObject!, forEvent: UIEvent!) &#123; struct xxx_buttonTapCounter &#123; static var count: Int = 0 &#125; xxx_buttonTapCounter.count += 1 print(xxx_buttonTapCounter.count) xxx_sendAction(action: action, to: to, forEvent: forEvent) &#125; @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125;&#125;extension UILabel:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UILabel.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UILabel.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; &#125;extension UITextField:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UITextField.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UITextField.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; &#125; 结语​ 到这里已经初步了解了Swizzling 的简单实用，虽然原理并不复杂但是解决了问题，白猫黑猫抓到老鼠就是好猫。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swizzling</tag>
      </tags>
  </entry>
</search>
