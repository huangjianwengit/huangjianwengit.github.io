<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OC与JS交互浅谈]]></title>
    <url>%2F2018%2F11%2F21%2FOC%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[前言​ 苹果端的程序开发审核是困扰开发人员的一大问题，不知多少iOS程序员与苹果爸爸做斗智斗勇，期望自己提交的应用能够一秒上线，当然这是不可能的奢望。虽然近两年苹果已经加速了审核速度，较之以前动则一两个星期的速度，可以说是大大提速了，但是相比较安卓端在审核速度上还是有所差距。为了解决这个问题APP内难免就会有一些web网页，这样在推出新的活动啥的，后台直接更新用户就可以看见啦，不必重新提交新的应用，节省了大量时间，关键是不用看苹果的脸色。 ​ 在工作历程中，有一次遇到这样一个状况：需要在一个web页面中实现分享的功能，web端的妹子是个刚毕业的新手，短时间无法实现这个功能，活动又要赶时间推出，没办法产品经理直接把这个皮球提给我们APP端了（谁让人家是妹子呢，妹子这种动物在程序员界那是大熊猫一样级别的国宝，不得好好照顾嘛）。最后折中采取了在web页面点击按钮，通过JS调用我们APP端的分享来实现这个活动的分享。 我使用了`JSExport`协议：凡是添加了`JSExpor`t协议的类或者协议，所规定的方法，变量等 就会对js开放，我们可以通过js调用到。首先创建OC类： ##添加协议 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol JSBridgeObjectProtocol &lt;JSExport&gt;/** 圣诞活动H5调用APP分享 @param url 分享Url @param shareContent 分享内容 */- (void)callOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)shareContent;- (void)callCommonOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)jsonString;@end@interface JSBridgeObject : NSObject&lt;JSBridgeObjectProtocol&gt;@end ​ 实现协议123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;JSBridgeObject.h&quot;//分享#import &quot;YXShareActivityModel.h&quot;#import &quot;UMShareUIManager.h&quot;#import &lt;UMSocialCore/UMSocialCore.h&gt;#import &lt;UShareUI/UShareUI.h&gt;@interface JSBridgeObject ()@property (nonatomic, strong) YXShareActivityModel *shareModel;@end@implementation JSBridgeObject/**活动JS调用的方法(JS调用写法和OC不一样 无参方法 TestJSobject.TestNOParameter(); 有一个参数的方法 TestJSobject.TestOneParameter(TestJSobject.name); 有两个参数的方法 TestJSobject.TestTwoParameterSecondParameter(TestJSobject.name,TestJSobject.age);**/ //实现协议方法- (void)callOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)shareContent&#123; //这里处理web要求帮忙做的事情&#125;- (void)callCommonOCShareWithShareUrl:(NSString *)url ShareContent:(NSString *)jsonString&#123; //这里处理web要求帮忙做的事情&#125;- (void)shareToOtherPlatformUrl:(NSString *)url ShareContent:(YXShareActivityModel *)shareModel&#123; //这里处理web要求帮忙做的事情&#125;@end 在合适的时机将我们的对象提供给web12345678910111213//获取到页面的title- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; if (!self.title || self.title.length == 0) &#123; self.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; &#125; JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; self.bridgeObject = [JSBridgeObject new]; context[@&quot;JSBridgeObject&quot;] = self.bridgeObject;&#125; 结语​ 好了到这里已经完美的接过了上面产品经理踢过来的皮球，展现了我大iOS开发人员的魅力，哈哈。。自我臭美中！互帮互助齐力完成任务，最后大家一起happy才是最美的事吗，在帮助别人的时候也是在帮助自己，工作中学习才是最快速的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swizzling[Objective-C]]]></title>
    <url>%2F2018%2F11%2F21%2FSwizzling-Objective-C%2F</url>
    <content type="text"><![CDATA[前言​ 前面的文章我已经介绍了Swift中的Swizzling Method，虽然swift语言有很多优点，但是毕竟是一门刚出来的语言，还处于发展过程中，苹果爹每年一次的大更新可折磨着一大堆苹果开发者。对于一般讲究效率和稳定的公司依旧青睐于Objective-C，毕竟大多数开发者还是比较熟悉的，节约了大多数学习和维护成本。 ​ 额。。。貌似扯得有点多，进入今天的正题吧，在OC中我们不必像swift中那样需要先解决方法的调用问题，API直接提供了两个方法+load（）和+initialize（）。OC本身就是运行时语言，不想swift静态性语言，虽然也能使用runtime，但是只是为了兼容OC，毕竟同一家公司不可能对自己家的东西不认可，那不是打自己脸。（又扯远了，手动尴尬-_-!） +load(): app启动的时候会加载所有的类,此时就会调用每个类的load方法。+initialize(): 第一次初始化这个类的时候会被调用。 ​ 今天依旧解决 字体适配 问题，这里我使用+load(): 方法，在这里替换我想要修改的方法，首先创建一个UIButton+myFont扩展文件，在UIButton+myFont.m文件中写上如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#import &quot;UIButton+myFont.h&quot;@implementation UIButton (myFont) + (void)load&#123; Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:)); Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:)); //用自定义的方法替换系统原始的方法 method_exchangeImplementations(imp, myImp); Method iwf = class_getInstanceMethod([self class], @selector(initWithFrame:)); Method myIwf = class_getInstanceMethod([self class], @selector(myInitWithFrame:)); method_exchangeImplementations(iwf, myIwf);&#125;//这里是为了Xib创建的控件也能有自适应字体大小的效果- (id)myInitWithCoder:(NSCoder*)aDecode&#123; [self myInitWithCoder:aDecode]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.titleLabel.tag != 333)&#123; CGFloat fontSize = self.titleLabel.font.pointSize; self.titleLabel.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;- (id)myInitWithFrame:(CGRect)frame&#123; [self myInitWithFrame:frame] ; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.titleLabel.tag != 333)&#123; CGFloat fontSize = self.titleLabel.font.pointSize; self.titleLabel.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;@end@implementation UILabel (myFont)+ (void)load&#123; Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:)); Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:)); method_exchangeImplementations(imp, myImp); Method iwf = class_getInstanceMethod([self class], @selector(initWithFrame:)); Method myIwf = class_getInstanceMethod([self class], @selector(myInitWithFrame:)); method_exchangeImplementations(iwf, myIwf);&#125;- (id)myInitWithCoder:(NSCoder*)aDecode&#123; [self myInitWithCoder:aDecode]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.tag != 333)&#123; CGFloat fontSize = self.font.pointSize; self.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self;&#125;- (id)myInitWithFrame:(CGRect)frame&#123; [self myInitWithFrame:frame]; if (self) &#123; //部分不像改变字体的 把tag值设置成333跳过 if(self.tag != 333)&#123; CGFloat fontSize = self.font.pointSize; self.font = [UIFont systemFontOfSize:MAIN_SCREEN_WIDTH_SCALE*(fontSize)]; &#125; &#125; return self; &#125; ​ 例子中我就只实现了UIButton和UILable两中控件，你可以同样的原理为UITextFiled、UITextView等控件做出适配，这里我就不一一做示范了，就是这么傲娇☺️。 ​ 其实runtime能做的事情很多字体大小适配只是其应用的很小部分，还有很多妙用等着大家挖掘，像无埋点，限制按钮点击次数等N多的用途，总之一句话：用好runtime，走上人生巅峰。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Swizzling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling[swift]]]></title>
    <url>%2F2018%2F11%2F20%2FSwizzling%5BSwift%5D%2F</url>
    <content type="text"><![CDATA[前言​ 在日常开发中，程序员（媛）要面对各种各样的需求，在某些特殊情况下Apple提供的API无法满足我们的需求，这时runtime就派上了用场。 Swift中被废弃的+load（）和+initialize（）我们知道OC中有两个方法+load（）和+initialize（）。 +load(): app启动的时候会加载所有的类,此时就会调用每个类的load方法.+initialize(): 第一次初始化这个类的时候会被调用. 然而在目前的swift版本中这两个方法都不可用了,那现在我们要在这个阶段搞事情该怎么做? 例如method swizzling这个强大的神器，作为为坚强的人类——程序员怎么可能就这样屈服呢。 JORDAN SMITH大神给出了一种很巧解决方案.UIApplication有一个next属性,它会在applicationDidFinishLaunching之前被调用,这个时候通过runtime获取到所有类的列表,然后向所有遵循SelfAware协议的类发送消息. ##交换方法Methond Swizzling 黑魔法Method Swizzling在swift中实现的两个要点 swizzling 应该保证只会执行一次. swizzling 应该在加载所有类的时候调用. 下面给出了两个示例供参考: 123456789101112131415161718192021222324252627282930313233343536373839404142protocol SelfAware: class &#123; static func awake() static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector)&#125;extension SelfAware &#123; static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) &#123; let originalMethod = class_getInstanceMethod(forClass, originalSelector) let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) guard (originalMethod != nil &amp;&amp; swizzledMethod != nil) else &#123; return &#125; if class_addMethod(forClass, originalSelector, method_getImplementation(swizzledMethod!), method_getTypeEncoding(swizzledMethod!)) &#123; class_replaceMethod(forClass, swizzledSelector, method_getImplementation(originalMethod!), method_getTypeEncoding(originalMethod!)) &#125; else &#123; method_exchangeImplementations(originalMethod!, swizzledMethod!) &#125; &#125;&#125;class NothingToSeeHere &#123; static func harmlessFunction() &#123; let typeCount = Int(objc_getClassList(nil, 0)) let types = UnsafeMutablePointer&lt;AnyClass&gt;.allocate(capacity: typeCount) let autoreleasingTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass&gt;(types) objc_getClassList(autoreleasingTypes, Int32(typeCount)) for index in 0 ..&lt; typeCount &#123; (types[index] as? SelfAware.Type)?.awake() &#125; types.deallocate() &#125;&#125;extension UIApplication &#123; private static let runOnce: Void = &#123; NothingToSeeHere.harmlessFunction() &#125;() override open var next: UIResponder? &#123; UIApplication.runOnce return super.next &#125;&#125; 在SelfAware的extension中为swizzlingForClass做了默认实现,相当于一层封装。引自Dariel 实际应用在之前已经完成了Swizzling的实现，但是我们要学会使用啊，磨好了武器不能留着上锈啊（说干就干）。在平时做项目过程中我们需要对不同屏幕尺寸做出适配，包括字体适配。写一个控件就去适配，费时费力，不会偷懒的程序员不是好程序员（这里的偷懒可不是不做事，而是想办法用最简单的方式实现同样的效果）。 新建FontAdapter.swift文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329import Foundationimport UIKitlet screenwidthScale = Screen.Width/320.0let screenheightScale = Screen.Height/568.0// MARK: - 使用运行时实现font大小自适应extension UIButton:SelfAware&#123; static func awake() &#123; UIButton.takeOnceTime swizzleMethod &#125; private static let takeOnceTime: Void = &#123; let originalSelector = #selector(sendAction) let swizzledSelector = #selector(xxx_sendAction(action:to:forEvent:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) &#125;() private static let swizzleMethod:Void = &#123; let originalSelector1 = #selector(UIButton.init(frame:)) let swizzledSelector1 = #selector(swizziedInit(frame:)) ///交换方法 swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) let originalSelector2 = #selector(UIButton.init(coder:)) let swizzledSelector2 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector2, swizzledSelector: swizzledSelector2) &#125;() @objc public func xxx_sendAction(action: Selector, to: AnyObject!, forEvent: UIEvent!) &#123; struct xxx_buttonTapCounter &#123; static var count: Int = 0 &#125; xxx_buttonTapCounter.count += 1 print(xxx_buttonTapCounter.count) xxx_sendAction(action: action, to: to, forEvent: forEvent) &#125; @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.titleLabel?.tag != 10000)&#123; let fontSize = self.titleLabel?.font.pointSize if fontSize != nil&#123; self.titleLabel?.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125;&#125;extension UILabel:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UILabel.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UILabel.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font.pointSize self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize) &#125; &#125; &#125;extension UITextField:SelfAware&#123; static func awake() &#123; swizzleMethod &#125; private static let swizzleMethod:Void = &#123; let originalSelector = #selector(UITextField.init(frame:)) let swizzledSelector = #selector(swizziedInit(frame:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector, swizzledSelector: swizzledSelector) let originalSelector1 = #selector(UITextField.init(coder:)) let swizzledSelector1 = #selector(swizziedInit(coder:)) swizzlingForClass(UIButton.self, originalSelector: originalSelector1, swizzledSelector: swizzledSelector1) &#125;() @objc public func swizziedInit(frame:CGRect)&#123; swizziedInit(frame: frame) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; @objc public func swizziedInit(coder:NSCoder)&#123; swizziedInit(coder: coder) //部分不想改变字体的 把tag值设置成跳过 if(self.tag != 10000)&#123; let fontSize = self.font?.pointSize if fontSize != nil&#123; self.font = UIFont.systemFont(ofSize: screenwidthScale * fontSize!) &#125; &#125; &#125; &#125; ##结语 ​ 到这里已经初步了解了Swizzling 的简单实用，虽然原理并不复杂但是解决了问题，白猫黑猫抓到老鼠就是好猫。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swizzling</tag>
      </tags>
  </entry>
</search>
